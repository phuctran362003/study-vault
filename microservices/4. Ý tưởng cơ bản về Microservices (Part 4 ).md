# IV. Trời sinh Du (Sync) sao còn sinh Lượng (Async)

Ở mục trước, chúng ta đã xem qua một ứng dụng thương mại điện tử đơn giản, và thấy rằng nếu ta thêm một service mới cần phụ thuộc vào dữ liệu từ các service khác, mọi thứ bắt đầu trở nên rắc rối một cách nhanh chóng khi mà tuân theo mô hình "Database per service" bởi vì service ListOrderedProducts không thể trực tiếp truy cập dữ liệu từ database của các service khác.

Vì vậy trong phần này mình sẽ có 2 sách lược để anh em thi triển và giải quyết vấn đề Chubby như Tr... à mà thôi. Hai sách lược này chủ yếu xoay quanh cách các service giao tiếp với nhau. Và đó là:

## 1. Synchronous Communication (Giao tiếp đồng bộ)

Trong mô hình giao tiếp đồng bộ, một service gửi yêu cầu trực tiếp đến một service khác và chờ phản hồi trước khi tiếp tục xử lý. Ví dụ, Service A gọi Service B để lấy dữ liệu, và chỉ khi nhận được kết quả từ Service B thì Service A mới tiếp tục gọi Service C. Quá trình này diễn ra theo chuỗi tuần tự, trong đó mỗi bước đều phụ thuộc vào kết quả của bước trước, đó chính là đặc điểm của **Synchronous Communication**.

Lấy lại ví dụ ứng dụng thương mại điện tử hồi nãy, chúng ta có bốn service User, Product, và Order, ListOrderedProducts.

Giả sử người dùng gửi yêu cầu đến service ListOrderedProducts với nội dung: “Hiển thị tất cả sản phẩm mà người dùng số 1 đã đặt hàng.” Chúng ta sẽ có các bước như sau:

![a.png](https://images.viblo.asia/24220970-e405-4365-8bd1-b554374b55b7.png)

- Bước 1: Service ListOrderedProducts gửi yêu cầu tới Service User để kiểm tra xem user đó có tồn tại không.
- Bước 2: Nếu user tồn tại, ListOrderedProducts gửi tiếp yêu cầu đến Service Order để lấy danh sách đơn hàng của người dùng đó.
- Bước 3: Từ danh sách đơn hàng, ListOrderedProducts gọi Service Product để lấy thông tin chi tiết về sản phẩm.

Cuối cùng sau 3 bước chờ đợi, Service ListOrderedProducts đã có đủ dữ liệu để trả kết quả cho người dùng.

Trong suốt quá trình này, Service ListOrderedProducts không hề truy cập trực tiếp vào database của bất kỳ service nào khác.

### Chu Du thực sự rất giỏi (Ưu điểm)

- Mô hình đồng bộ rất dễ hiểu, dễ hình dung.
- Service ListOrderedProducts không cần có database riêng, vì nó chỉ phụ thuộc dữ liệu từ các service khác.

### Nhưng không phải là toàn năng (Nhược điểm)

- Nếu một trong các service phụ thuộc (ví dụ User) bị sập, thì ListOrderedProducts cũng không hoạt động được.
- Chỉ cần một request giữa các service thất bại, toàn bộ luồng xử lý bị lỗi.
- Tốc độ xử lý phụ thuộc vào service chậm nhất. Ví dụ: nếu request đến User mất 10ms, đến Order mất 10ms, nhưng đến Product mất 20 giây thì tổng thời gian cũng sẽ là hơn 20 giây.
- Một nhược điểm khó thấy hơn đó là chuỗi gọi đồng bộ như thế này có thể dẫn đến một mạng lưới phụ thuộc phức tạp và khó kiểm soát. Ví dụ: service ListOrderedProducts gọi User, User lại gọi Q, Q tiếp tục gọi Z và X... và như vậy một request đơn giản từ ListOrderedProducts có thể dẫn đến hàng chục hoặc hàng trăm lời gọi nội bộ phía sau. Và một lần nữa, nếu chỉ một trong các bước đó lỗi, toàn bộ yêu cầu sẽ thất bại.

### The easier the investment, the higher the risk

Giao tiếp đồng bộ có những điểm mạnh của riêng nó, nhưng đi kèm là rủi ro vận hành cực kỳ lớn.

Mục đích chính của Microservices luôn luôn khuyên bạn hãy trở thành một Lonely wolf, luôn chơi một mình, không được phụ thuộc vào người khác, tự làm tốt vai trò của chính mình. Còn làm như thế nào á, thế thì phải xem Gia Cát Lượng rùi.

## 2. Asynchronous Communication (Giao tiếp bất đồng bộ)

Trong mô hình giao tiếp bất đồng bộ, một service có thể gửi yêu cầu đến service khác mà không cần chờ phản hồi ngay lập tức. Thay vì đợi kết quả, service gửi đi tiếp tục xử lý các công việc khác, và phản hồi (nếu có) sẽ được xử lý sau khi nhận được. Ví dụ, Service A gửi một sự kiện hoặc message đến Service B thông qua một cái gọi là Event Bus (Mình sẽ giải thích rõ ở phần dưới), và không cần biết khi nào Service B xử lý xong, đây chính là đặc trưng của Asynchronous Communication.

Chúng ta sẽ có hai cách triển khai. Cách đầu tiên dù là Async nhưng vẫn có nhược điểm giống Sync, nhưng chúng ta vẫn sẽ đi qua 2 cách để hiểu nhé, nhưng trước đó chúng ta cần phải nắm một số thông tin đã.

### Event Bus là gì?

Về cơ bản, với giao tiếp bất đồng bộ, ta sẽ thêm một thành phần chung mà mọi service đều có thể kết nối vào. Thành phần này được gọi là một event bus, tạm hiểu là “xe buýt truyền sự kiện”.

![image.png](https://images.viblo.asia/09742eac-710c-4d52-8f3b-a1ecc970f58f.png)Mục tiêu của event bus là nhận và phân phối các sự kiện (event) được gửi ra từ các service khác nhau.

Mỗi event giống như một “tờ giấy ghi chú” nói rằng: “Có chuyện gì đó vừa xảy ra” hoặc “cần xử lý việc này”.

Mỗi service kết nối với event bus đều có thể gửi sự kiện ra, hoặc lắng nghe các sự kiện từ service khác.

### Cách triển khai với Event Bus đầu tiên

Giả sử Service ListOrderedProducts nhận được yêu cầu: “Hiển thị tất cả sản phẩm mà user #1 đã đặt hàng.”

**Bước 1: Gửi Event truy vấn người dùng**

![image.png](https://images.viblo.asia/aa4a64e6-b1cd-4a93-8b2a-a76eaa251f00.png)ListOrderedProducts gửi một event với type là user:query và dữ liệu là userId = 1.

**Bước 2: Event Bus chuyển tiếp event đến Service User**

![image.png](https://images.viblo.asia/ad01d309-0850-455a-be0b-0547cef37094.png)Event bus chuyển event này đến Service User, nơi chịu trách nhiệm xử lý dữ liệu người dùng.

**Bước 3: Service User phản hồi bằng event mới**

![image.png](https://images.viblo.asia/8951ffc4-7dd6-41c7-9532-c2505dd74d38.png)Sau khi xử lý xong, A gửi một event mới chứa thông tin user (ví dụ: Id = 1, name = "Tanjiro").

**Bước 4: Event Bus chuyển kết quả về cho Service ListOrderedProducts**

![image.png](https://images.viblo.asia/5cf0ea80-07d2-4cb3-a3e6-79a413e94b2c.png)

**Các bước tiếp theo (tương tự)**

Service ListOrderedProducts tiếp tục gửi event để lấy đơn hàng từ Service Order, và lấy thông tin sản phẩm từ Service Product.

**Cũng ra gì và này nọ đấy, nhưng vẫn chưa tài đâu**

Cách này gặp lại những nhược điểm y chang mô hình giao tiếp đồng bộ...

- Các Service vẫn phụ thuộc lẫn nhau: Dù dùng event, nhưng Service ListOrderedProducts vẫn phụ thuộc vào User/Order/Product để xử lý đúng. Nếu User hoặc Order không phản hồi thì ListOrderedProducts cũng “bó tay”.
- Vẫn bị trễ theo service chậm nhất: Tốc độ phản hồi của toàn bộ request vẫn phụ thuộc vào service chậm nhất.
- Mạng lưới phụ thuộc phức tạp: Dễ sinh ra một “mạng nhện” phức tạp giữa các service qua lại bằng event. Khó trace, khó debug.
- Event có thể bị mất: Nếu một event nào đó bị mất hoặc không xử lý kịp, luồng xử lý sẽ bị lỗi hoàn toàn.

Dù vậy service ListOrderedProducts vẫn không cần Database riêng, các service không gọi trực tiếp lẫn nhau và nhiều hệ thống ngoài đời vẫn còn dùng cách này.

Chúng ta sẽ tiếp tục với cách còn lại.

### Cách còn lại được anh Stephen gọi nó là: "A Crazy Way of Storing Data"

Ý tưởng của cách này phải ví như mưu lược mà Gia Cát Lượng lấy mũi tên của quân Tào Tháo tại trận Xích Bích vậy. Quá đỉnh cao và điên rồ.

Cách này chúng ta sẽ đạt được pattern "Data per service" và sự độc lập tuyệt đối giữa các service mà chúng ta vẫn theo đuổi.

**Ý tưởng:**

- Chúng ta sẽ tạo một database riêng cho service ListOrderedProducts để lưu những thông tin cần thiết thực hiện cho nhiệm vụ truy vấn “Hiển thị tất cả sản phẩm mà user đã đặt hàng.”
- Dùng Event bus để đẩy những sự kiện phát ra từ các service để lưu vào database của service ListOrderedProducts.

Ý tưởng chung chung là vậy, chúng ta sẽ để Event bus thu thập các event rồi gửi lại cho service ListOrderedProducts nó lưu, lúc cần thì tự nó lấy ra sử dụng thôi.

**Triển khai thử thôi**

Hãy xác định rõ chức năng của Service ListOrderedProducts: Với một user ID, service ListOrderedProducts phải trả về tên và ảnh của tất cả sản phẩm người dùng đó đã từng đặt mua.

Giờ chúng ta hãy thiết kế một cấu trúc database để phục vụ mục tiêu này.

![image.png](https://images.viblo.asia/aeef9bad-a34f-4fcd-9a97-8d78f545aec8.png)

Ta sẽ có một bảng users lưu user ID và danh sách ID sản phẩm họ đã mua. Bảng products sẽ lưu ID, tên và ảnh của từng sản phẩm.

Giờ ta chỉ cần tra danh sách ID sản phẩm từ user, rồi lấy thông tin từ bảng sản phẩm là có ngay thông tin người dùng cần.

**Tiếp đến là cách lấy dữ liệu và lưu vào database service ListOrderedProducts**

Mỗi khi có sản phẩm mới ta tạo một event gửi lên event bus, sau đó để event bus gửi đến cho service ListOrderedProducts:

![image.png](https://images.viblo.asia/fbfb2c3e-4016-499e-abf0-e0b54340dd74.png)

Tương tự với Service User: khi user đăng ký, nó phát UserCreated chỉ chứa user ID. ListOrderedProducts nhận event và tạo bản ghi user mới, với danh sách sản phẩm rỗng.

![image.png](https://images.viblo.asia/85c07b82-c582-45c4-ae02-317f14ebb8fa.png)

Sau đó, khi user mua hàng qua Service Order, nó phát event OrderCreated gồm user ID và product ID. ListOrderedProducts nhận được và cập nhật thêm sản phẩm vào danh sách của user đó.![image.png](https://images.viblo.asia/7fdb69f8-4ccd-47df-9032-2921a92d20f4.png)

Bây giờ database của Service ListOrderedProducts đã đầy đủ và hoạt động độc lập. Nó có thể trả lời ngay: "Người dùng X đã đặt gì?" mà không cần gọi ai khác.

**Ưu điểm:**

1. Một service hoàn toàn không phụ thuộc vào các service khác.
2. Ngay cả khi các service User, Order, Product gặp sự cố hoặc ngừng hoạt động, Service ListOrderedProducts vẫn hoạt động hoàn toàn bình thường, bởi vì nó độc lập và đã có dữ liệu sẵn.
3. Tốc độ phản hồi rất nhanh do Service ListOrderedProducts có sẵn dữ liệu trong database của riêng mình, nên nó có thể truy xuất và phản hồi cực kỳ nhanh chóng mà không cần gọi bất kỳ service nào khác.

**Nhược điểm:**

> Khó hiểu và triển khai vãi cả nồi

Một nhược điểm khác bạn có thể đang thắc mắc đó là sự Trùng lặp dữ liệu (Data duplication) khi mà dữ liệu như thông tin người dùng, sản phẩm hay đơn hàng sẽ được lưu cả ở database gốc của các service Order, User, Product, và một phần trong database của Service ListOrderedProducts.

Nhưng nó không thực sự là nhược điểm khi mà chi phí lưu trữ dự liệu ngày nay với sự phát triển của phần cứng đã khiến cho chi phí lưu trữ không còn là vấn đề. Đây là ví dụ của anh Sờ Ti Phờn:

```none
* Lưu 1GB dữ liệu trên Azure MySQL: khoảng 11.5 cent/tháng
* Trên AWS hay Google Cloud: khoảng 17 cent/tháng
* Vậy dữ liệu một sản phẩm thì chiếm bao nhiêu?
* Tôi lấy một response thật từ API của Amazon cho một sản phẩm (với đầy đủ dữ liệu JSON) – nó chỉ nặng khoảng 1,200 byte.
* Giả sử bạn lưu 100 triệu sản phẩm, chi phí chỉ khoảng 14 đô/tháng.
```

# V. Tổng kết

Trời ơi bài viết này đã thực sự tốn cả 2 tuần của mình chỉ để nghiên cứu và viết lại sao cho dễ hiểu.

Mình xin nhắc lại là bài viết của mình không thể thay thế được những kiến thức khóa học từ anh Sờ Te Phờn, các bạn hãy đăng ký và trải nghiệm thử.

Ở phần sau chúng ta sẽ tiếp đến phần thực hành code để triển khai một mớ lý thuyết chúng ta đã đi từ đầu tới giờ.

Nếu bạn thấy hay thì cho mình xin 1 upvote và để lại comment những chỗ mình đã sai, hoặc muốn thảo luận thêm nhé.