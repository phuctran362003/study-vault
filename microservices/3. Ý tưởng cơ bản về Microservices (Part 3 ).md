# III. Nói thì dễ - Làm mới khó

Ở ví dụ này thì mình xin phép mượn ý tưởng E-Commerce của anh Stephen Grider để trình bày luôn, tại mình lười vẽ hình á =))).

**Ví dụ: Ứng dụng thương mại điện tử đơn giản**

Hãy nhìn vào sơ đồ sau:

![image.png](https://images.viblo.asia/1f8d206b-ba72-47a8-895d-fb8ff25bec38.png)Ứng dụng này chỉ có 3 chức năng rất đơn giản:

1. Cho phép người dùng đăng ký tài khoản (sign up).
2. Hiển thị danh sách sản phẩm như mũ, quần, giày.
3. Cho phép người dùng mua sản phẩm.

## Trường hợp 1: Kiến trúc Monolithic

Hãy tưởng tượng rằng tôi và bạn đang xây dựng ứng dụng này theo mô hình monolithic quen thuộc.

- Chúng ta sẽ có thể tạo các thư mục như model, repository, cotroller, service,... Nhưng tựu chung lại thì chúng ta vẫn sẽ viết hết vào một thư mục tổng đúng chứ?
- Sau đó chúng ta sẽ chọn một loại CSDL nào đó như MySQL, MongoDB,... rồi để app của chúng ta kết nối đến CSDL này.
- Sau đó, trong CSDL này chúng ta sẽ tạo ra 3 bảng (hoặc collection): **users (Để triển khai tính năng đăng ký)**, **products (Để triển khai tính năng hiển thị sản phẩm)** và **orders (Để triển khai tính năng mua sản phẩm)**
    
    ![image.png](https://images.viblo.asia/fedc878e-46d9-49b0-adae-f1109a2162bc.png)

Giả sử giờ chúng ta muốn thêm một tính năng mới:

> _Hiển thị danh sách sản phẩm mà một người dùng cụ thể đã mua._

Trong mô hình monolithic, chúng ta sẽ triển khai tính năng cực kỳ dễ dàng như sau:

![image.png](https://images.viblo.asia/54cd898d-1ca8-4650-a635-e71b3f1cae0c.png)

- Truy vấn bảng users để kiểm tra user có tồn tại không
- Truy vấn bảng orders để tìm các đơn hàng do người đó tạo
- Truy vấn bảng products để lấy chi tiết các sản phẩm đã được mua

Tất cả chỉ là các truy vấn trong cùng một cơ sở dữ liệu, rất đơn giản, rất hiệu quả.

## Trường hợp 2: Kiến trúc Microservices

Giờ ta thử chuyển đổi ứng dụng này sang mô hình microservices.

Chúng ta sẽ chia ứng dụng thành 3 service:

![image.png](https://images.viblo.asia/f346ac95-5f8c-44ad-997e-67c4322d4bd9.png)

- Service User: xử lý đăng ký người dùng
- Service Product: quản lý danh sách sản phẩm
- Service Order: xử lý việc tạo đơn hàng (mua sản phẩm)

Mỗi service có database riêng của nó.

### Vấn đề phát sinh

Giả sử bây giờ ta muốn thêm một Service ListOrderedProducts, có nhiệm vụ:

**Hiển thị danh sách sản phẩm mà một người dùng cụ thể đã đặt mua.**

Nếu ta nghĩ như cách trong monolithic, chúng ta có thể làm như sau:

![image.png](https://images.viblo.asia/6b30f02b-b2ff-43a4-85f1-0b11ae113b66.png)

- Service ListOrderedProducts sẽ gọi đến database của Service User để lấy thông tin user.
- Sau đó gọi đến database của Service Order để lấy đơn hàng.
- Cuối cùng gọi đến database của Service Product để lấy chi tiết sản phẩm.

**Nhưng!!! chúng ta đã nói gì nào?**

> Trong kiến trúc microservices, một service không được phép truy cập trực tiếp vào database của service khác.

Vậy câu hỏi đặt ra là:

> Làm sao chúng ta có thể xây dựng được Service ListOrderedProducts mà không được truy cập vào dữ liệu của các service khác?

### Và đó chính là Big Problem

Đây là cốt lõi của bài toán quản lý dữ liệu trong microservices:

> Chúng ta muốn mở rộng hoặc thay đổi ứng dụng. Nhưng lại không được truy cập trực tiếp dữ liệu từ service khác. Vậy thì làm sao lấy được dữ liệu cần thiết?

Đó chính là lý do vì sao quản lý dữ liệu giữa các service là rất khó. Ngoài ra còn rất nhiều vấn đề khác nữa, nhưng đây là vấn đề đầu tiên và khó nhai khi bạn tiếp cận về kiến trúc microservices.

**Do you give up? No... No... Nothing can beats a jet 2 holidays =))) Khó khó mới hay chứ đúng không ạ, mình sẽ nói tiếp cách hóa giải chiêu 2 Điêu Thuyền ở mục tiếp theo hẹ hẹ.**


