Credit: NekoArcoder - [https://viblo.asia/u/trandatk](https://viblo.asia/u/trandatk)

# 1. Monolithic là một Hurricane Green Robot???:

Để trả lời cho câu hỏi này, chúng ta cần phải xem lại kiến trúc **Monolithic** mà thời sinh viên chúng ta đã làm việc với nó hàng ngày trước.

Tất cả mã nguồn cần thiết để xây dựng ứng dụng của chúng ta đều được gói gọn trong một **codebase duy nhất**, và chúng ta triển khai toàn bộ codebase đó như một **khối thống nhất**.

Minh họa cho một kiến trúc Monolithic khi một request được gửi tới như sau:

![[Pasted image 20251117224342.png]]

Hơi lý thuyết rồi, mọi người cứ tưởng tượng **Monolithic** giống như là một con Robot của siêu nhân xanh trong Siêu nhân cuồng phong vậy.

![[Pasted image 20251117224349.png]]

Đây là một con **Robot nguyên khối**, các bộ phận tay, chân, đầu đều gắn liền với nhau không thể tách rời.

*Vẫn hoạt động ngon lành, mạnh, nhanh, do nó chỉ được điều khiển bởi một thằng siêu nhân thôi, nên khi có một yêu cầu đánh đấm thì chỉ cần ra lệnh, thì mệnh lệnh đó được truyền trực tiếp đến bộ phận đó xử lý và thực hiện thao tác ngay, không cần bước trung gian gì cả.*

### Ưu điểm:

- Nhạc thì thấm, đấm thì đau, nhỏ nhỏ mà có võ, đấm vỡ alo các loại quái từ nhỏ tới trung bình, phù hợp với đại đa số nhu cầu (Tức là nếu bạn là doanh nghiệp nhỏ, CCU chỉ ở mức nhỏ đến trung bình thì **Monolithic** là quá đủ).
- Vì là một chiếc trực thăng biến ra nên nó khá nhỏ, dễ bảo trì và gắn thêm các đồ chơi cho nó (Khi là một khối thì việc bảo trì và phát triển thêm tính năng cũng rất rất đơn giản, miễn là có doc đủ rõ ràng và clean code là được).
- Chi phí phát triển và tu dưỡng thấp. (Nhỏ nhỏ thì chi phí phát triển và bảo trì sẽ không cao rùi).

### Nhược điểm:

- Khi trùm cuối xuất hiện thì sức mạnh một mình đã không còn đủ nữa, lúc này bạn chỉ mong mình là Naruto để thực hiện thông não chi thuật con Boss (Khi số lượng CCU hoặc độ lớn của dự án cực kỳ khủng thì **Monolithic** đã không còn phù hợp nữa - *Instagram là một ngoại lệ nhé*.)
- Khi một bộ phận như tay, chân bị hỏng thì Robot gần như bị loại khỏi cuộc chơi, không thể tháo lắp bộ phận do nó là một khối thống nhất, chỉ có thể đem vào lại bảo trì thui. (Ở các dự án yêu cầu downtime cực kỳ thấp thì việc này không thể chấp nhận được.). Có thể khắc phục điểm yếu này bằng cách tăng số lượng instance (Trong ví dụ này bạn cứ hiểu là tăng số lượng bản thể của Hurricane Green Robot ấy), nhưng có thật sự phải scale toàn bộ hệ thống không? *Ví dụ như chỉ có một tính năng duy nhất là đang bị quá tải, những tính năng còn lại thì rảnh rỗi mà chúng ta lại scale cả hệ thống lên, chắc chắn sẽ rất lãng phí thay vì scale đúng tính năng đó thôi.*
- Cả con robot phải có sự đồng điệu về mặt màu sơn =)))) ý mình là nó chỉ được sử dụng những bộ phận cùng một mẫu mã thôi, thành ra muốn thay một mẫu mã khác vào thì hơi "khó" (Ý mình là dự án của bạn phải code theo một framework hoặc ngôn ngữ duy nhất, điều này nó khiến cho dự án hơi "Khô khan" và không tận dụng được sức mạnh của các framework hoặc ngôn ngữ khác).
- Sự cồng kềnh khi muốn Robot mạnh hơn thì phải độ thêm nhiều đồ chơi hơn hoặc phải tự nâng cấp động cơ, dẫn đến sự độ chế phá vỡ kỹ thuật, về lâu về dài sẽ trở thành một con Robot Ục ịch trì trệ (Tương tự như vậy, khi việc nhân sự luôn thay đổi trong một dự án luôn là điều bình thường ở các công ty, nên sẽ luôn có sự chồng chéo logic hoặc tự "độ chế" code dẫn tới một đống bùi nhùi.)

# 2. Microservice là một Robot được kết hợp từ các bộ phận khác nhau

Bây giờ, chúng ta sẽ dựa vào sơ đồ ở phần 1 và chỉ cần thay đổi một vài điểm để mô tả để hiểu microservices là gì.

![](data:image/png;base64,iVBORw0KGgoAAAANy... [truncated]

Chúng ta định nghĩa microservice như sau:

> Một **microservices** về bản chất sẽ chứa chính các **Monolothic** đơn lẻ đã bao gồm các routing, middleware, logic nghiệp vụ và code truy cập cơ sở dữ liệu cần thiết để hiện thực một **tính năng duy nhất** của ứng dụng.

**Đây chính là sự khác biệt cốt lõi:**

- **Monolith** chứa tất cả mã nguồn cần thiết để hiện thực mọi tính năng của ứng dụng.
- Một **Microservice** đơn lẻ thì chỉ chứa mã nguồn cần thiết cho một **tính năng duy nhất**.

Trong kiến trúc microservices, chúng ta sẽ tách từng tính năng riêng biệt và đóng gói chúng vào các service độc lập. Ví dụ qua hình sau:

![](data:image/png;base64,iVBORw0KGgoAAAANy... [truncated]

**Điểm cực kỳ quan trọng bạn luôn phải nhớ đó chính là:**

> Mỗi service là **hoàn toàn độc lập, tự chứa (self-contained)** code của chính nó để thực hiện một **tính năng duy nhất**.

Cứ tưởng tượng dự án Microservices của bạn là một con Robot của 5 thằng siêu nhân gộp lại thành một con Robot tổng vậy, mỗi một con sẽ đóng vai trò như đầu, thân, tay, chân,...

*Mỗi con đều có thể tự hoạt động độc lập, không phụ thuộc vào nhau, chiến đấu một cách riêng lẻ.*

Khi chúng kết hợp lại thì sẽ tạo thành một khối thống nhất nhưng vẫn đạt được trạng thái **Loose coupling**. Có thể dễ dàng thay thế một bộ phận bởi một một bộ phận khác khi bị hỏng ngay trên chiến trường mà không phải đem cả khối Robot lớn đi bảo trì.

Khi muốn thêm một bộ phận mới thì cũng không ảnh hưởng các bộ phận cũ, từ đó chiến đấu mượt mà hơn mà không có độ trễ.

### Vậy tổng kết lại, chúng ta hiểu kiến trúc Microservices như sau:

> Một **microservice** đơn lẻ sẽ chứa toàn bộ mã nguồn cần thiết để giúp một **tính năng của ứng dụng** hoạt động.