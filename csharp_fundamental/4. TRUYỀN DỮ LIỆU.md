# 1. Truyền dữ liệu vào phương thức (Passing Data to a Method)

Trong C#, có hai kiểu dữ liệu chính: **Kiểu tham trị (Value Types)** và **Kiểu tham chiếu (Reference Types)**. Cách chúng được truyền vào phương thức sẽ khác nhau.

- **Value Types**: `int`, `double`, `bool`, `char`, `struct`, `enum`. Chúng chứa dữ liệu trực tiếp.
- **Reference Types**: `string`, `class`, `array`, `delegate`. Chúng chứa một tham chiếu (địa chỉ) trỏ đến nơi dữ liệu được lưu trữ trong bộ nhớ (heap).

## a. Truyền tham trị (Pass by Value)

Đây là **cách mặc định** trong C#.

| | Mô tả | Ví dụ |
| :--- | :--- | :--- |
| **Khi truyền Value Type** | Một **bản sao (copy)** của biến được tạo ra và truyền vào phương thức. Mọi thay đổi trên bản sao bên trong phương thức **không ảnh hưởng** đến biến gốc. | ```csharp
void Main()
{
    int originalValue = 10;
    Console.WriteLine($"Original before: {originalValue}"); // Output: 10
    
    ModifyValue(originalValue);
    
    Console.WriteLine($"Original after: {originalValue}"); // Output: 10 (không đổi)
}

void ModifyValue(int valueCopy)
{
    valueCopy = 99; // Chỉ thay đổi bản sao
}
``` |
| **Khi truyền Reference Type** | Một **bản sao của tham chiếu (địa chỉ)** được truyền vào phương thức. Vì cả hai tham chiếu (gốc và bản sao) đều trỏ đến **cùng một đối tượng** trong bộ nhớ, nên: <br> - Nếu bạn thay đổi **thuộc tính của đối tượng** bên trong phương thức, đối tượng gốc **sẽ bị thay đổi**. <br> - Nếu bạn gán tham chiếu bản sao cho một **đối tượng mới** (`new`), biến gốc **không bị ảnh hưởng**. | ```csharp
class Student { public string Name { get; set; } }

void Main()
{
    Student student = new Student { Name = "John" };
    Console.WriteLine($"Original before: {student.Name}"); // Output: John

    ModifyReference(student);

    Console.WriteLine($"Original after: {student.Name}"); // Output: Doe (đã bị thay đổi)
}

void ModifyReference(Student studentRefCopy)
{
    // Thay đổi thuộc tính của đối tượng mà tham chiếu đang trỏ tới
    // -> Đối tượng gốc bị thay đổi.
    studentRefCopy.Name = "Doe";

    // Gán tham chiếu bản sao cho một đối tượng mới
    // -> Không ảnh hưởng đến biến gốc.
    studentRefCopy = new Student { Name = "Jane" };
}
``` |

---

## b. Truyền tham chiếu (Pass by Reference)

Cách này cho phép phương thức truy cập và thay đổi trực tiếp biến gốc, bất kể nó là Value Type hay Reference Type. Ta sử dụng các từ khóa `ref`, `out`, và `in`.

| Từ khóa | Mô tả | Ví dụ |
| :--- | :--- | :--- |
| **`ref`** | - Truyền vào **chính biến gốc** (không phải bản sao).<br>- Mọi thay đổi bên trong phương thức sẽ **ảnh hưởng trực tiếp** đến biến gốc.<br>- Biến truyền vào **phải được khởi tạo giá trị** trước khi gọi hàm. | ```csharp
void Main()
{
    int originalValue = 10;
    Console.WriteLine($"Original before: {originalValue}"); // Output: 10
    
    ModifyWithRef(ref originalValue);
    
    Console.WriteLine($"Original after: {originalValue}"); // Output: 99 (đã thay đổi)
}

void ModifyWithRef(ref int originalVariable)
{
    originalVariable = 99; // Thay đổi trực tiếp biến gốc
}
``` |
| **`out`** | - Tương tự `ref`, nó truyền vào **chính biến gốc**.<br>- Mục đích chính là để một phương thức **trả về nhiều hơn một giá trị**.<br>- Biến truyền vào **không cần khởi tạo** trước, nhưng **bắt buộc phải được gán giá trị** bên trong phương thức được gọi. | ```csharp
void Main()
{
    // int number; // không cần khởi tạo
    if (int.TryParse("123", out int number))
    {
        Console.WriteLine($"Parse successful: {number}"); // Output: 123
    }
}

// Phương thức TryParse của C# là một ví dụ điển hình
// bool TryParse(string s, out int result)
// {
//     // ... logic
//     result = ...; // Bắt buộc phải gán giá trị cho result
//     return true/false;
// }
``` |
| **`in`** | - Truyền tham chiếu nhưng **không cho phép sửa đổi** (read-only).<br>- Mục đích là để **tăng hiệu năng** khi truyền các `struct` lớn, tránh việc copy tốn kém mà vẫn đảm bảo dữ liệu không bị thay đổi. | ```csharp
void Main()
{
    int readOnlyValue = 10;
    PrintValue(in readOnlyValue);
}

void PrintValue(in int value)
{
    Console.WriteLine(value);
    // value = 99; // Lỗi biên dịch! Không thể sửa đổi.
}
``` |

# 2. Thư viện Lớp (Class Library)

## a. Class Library là gì?

- Là một loại **Project** trong Visual Studio dùng để tạo ra các thành phần có thể **tái sử dụng**.
- Kết quả build của một Class Library là một file **DLL** (Dynamic Link Library).
- File **DLL** này có thể được tham chiếu và sử dụng bởi các project khác (như Console App, Web App, WinForms, ...).
- Nó **không có hàm `Main()`** và không thể tự chạy một mình.
- Mặc định, các `class` trong project là `internal` (chỉ dùng được trong cùng project). Để các project khác có thể dùng, `class` và các `method` của nó phải được khai báo là `public`.

## b. Cách tạo và sử dụng Class Library

Hãy xem ví dụ tạo một thư viện toán học và sử dụng nó trong một ứng dụng console.

**Bước 1: Tạo Class Library Project**

1.  Trong Visual Studio, tạo một project mới thuộc loại **Class Library**. Đặt tên là `MyMathLib`.
2.  Trong project `MyMathLib`, tạo một file `Calculator.cs` với nội dung sau:

```csharp
// File: MyMathLib/Calculator.cs
namespace MyMathLib
{
    // Phải là public để project khác thấy được
    public class Calculator
    {
        // Method cũng phải là public
        public int Add(int a, int b)
        {
            return a + b;
        }
    }
}
```

**Bước 2: Tạo Console App Project để sử dụng thư viện**

1.  Trong cùng **Solution**, chuột phải vào Solution Explorer, chọn **Add > New Project...**.
2.  Tạo một project mới thuộc loại **Console App**. Đặt tên là `MyApp`.
3.  Set `MyApp` làm **Startup Project** (chuột phải vào project `MyApp` > **Set as Startup Project**).

**Bước 3: Thêm tham chiếu (Add Reference)**

Để `MyApp` có thể "thấy" và sử dụng `MyMathLib`, bạn cần thêm một tham chiếu:

1.  Trong project `MyApp`, chuột phải vào mục **Dependencies**.
2.  Chọn **Add Project Reference...**.
3.  Trong tab **Projects**, tick vào `MyMathLib` và nhấn **OK**.

**Bước 4: Sử dụng thư viện trong Console App**

Mở file `Program.cs` trong project `MyApp` và viết code sau:

```csharp
// File: MyApp/Program.cs

// Dùng namespace của class library
using MyMathLib;

// Tạo đối tượng từ class library
Calculator calculator = new Calculator();

// Gọi method
int result = calculator.Add(5, 10);

Console.WriteLine($"The result is: {result}"); // Output: The result is: 15
```

Khi bạn chạy `MyApp`, nó sẽ sử dụng code từ file `MyMathLib.dll` để thực hiện phép tính. Đây là cách cơ bản nhất để xây dựng các ứng dụng lớn theo kiểu module hóa.
