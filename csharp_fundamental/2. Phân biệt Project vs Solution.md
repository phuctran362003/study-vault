# 1. Phân biệt **Project** vs **Solution**?

| | **Solution** | **Project** |
|---|---|---|
| **Định nghĩa** | Là 1 cái **APP**, là câu trả lời được thiết kế để **GIẢI QUYẾT** nhu cầu của 1 bộ phận **USER**. Vậy **APP** là **SOLUTION**. | Là tập hợp của 1 nhóm **CODE**, 1 nhóm các **class** dùng để **LÀM 1 chức năng RIÊNG BIỆT** nào đó. |
| **Cấu trúc** | 1 **SOLUTION** là 1 **APP** sẽ được làm trong tương lai.<br>VD: Anh em mê bóng đó thích có 1 phần mềm tổ chức/ chơi bóng -> **FIFA 2023** là 1 **SOLUTION** cho nhu cầu này. | 1 **SOLUTION** là cái **APP** bự gồm nhiều **PROJECT** bên trong để có được **APP** hoàn chỉnh các chức năng.<br>Chia 1 **SOLUTION** thành nhiều **PROJECT** để dễ quản lí **SOURCE CODE** “**Divide and Conquer – Chia để trị**“<br>**MỖI PROJECT** sẽ biến thành 1 **DLL** => 1 **APP/ SOLUTION** sẽ có nhiều **DLL**<br>Mỗi **PROJECT** là 1 **Library** (chứa nhiều **code**) -> **Dependency** |
| **Thao tác** | Đứng ở **Solution** ấn phải chuột => **Add** => **New Project** => 1 **solution** có nhiều **project** | Đứng ở **project** ấn phải chuột => **Add** => **New Item** (nhiều tập tin) => 1 **project** chứa nhiều **namespace** |
| **File vật lý** | Được quản lý bởi file `.sln` (Solution file). File này chứa thông tin về các project có trong solution và các cấu hình của chúng. | Được quản lý bởi file `.csproj` (C# Project file). File này chứa danh sách các file code, dependencies, và các thiết lập build cho project đó. |
| **Startup Project** | Trong một **Solution** có nhiều **Project**, bạn phải chọn một **Project** để chạy đầu tiên. **Project** này được gọi là **Startup Project**. | |
| **Tóm tắt** | >>>>> 1 **SOLUTION** LÀ 1 **APP** VÀ CÓ NHIỀU **PROJECT** BÊN TRONG<br><br>>>>>> 1 **PROJECT** LÀ 1 NHÓM **CODE** LÀM 1 VIỆC/ **CHỨC NĂNG** NÀO ĐÓ<br><br>>>>>> 1 **PROJECT** SẼ BIẾN THÀNH 1 **DLL** – 1 **THƯ VIỆN** – 1 **DEPENDENCY**<br><br>>>>>> 1 **PROJECT** CHỨA NHIỀU **NAMESPACE** – CHIA NHIỀU KHU VỰC CHỨA **CLASS** BÊN TRONG<br><br>>>>>> 1 **CLASS** CÓ NHIỀU **METHOD/FUNCTION** VÀ **ĐẶC TÍNH** BÊN TRONG (**PROPERTY**, **ATTRIBUTE**, **FIELD**,..)| |

# 2. **Coding Convention** (Quy tắc viết mã)

Dựa theo quy tắc của Microsoft.

| **Quy tắc đặt tên** | **Mô tả** | **Ví dụ** |
|---|---|---|
| **SOLUTION / PROJECT** | **PascalCase** | `MyAwesomeApp` |
| **NAMESPACE** | **PascalCase**, có thể dùng `.` để phân cấp | `MyAwesomeApp.DataAccess`, `MyAwesomeApp.Services` |
| **CLASS / ENUM / DELEGATE / EVENT** | **NOUN**, **PascalCase** | `Customer`, `StatusEnum`, `FileProcessedHandler` |
| **INTERFACE** | **PascalCase** và có tiền tố `I` | `IUserService`, `ILogger` |
| **HÀM/METHOD** | **VERB** + **OBJECT**, **PascalCase** | `GetCustomerById()`, `CalculateTotalPrice()` |
| **BIẾN CỤC BỘ (LOCAL VARIABLE)** | **camelCase** | `customerName`, `totalPrice` |
| **THAM SỐ HÀM (PARAMETER)** | **camelCase** | `void PrintName(string studentName) { ... }` |
| **HẰNG SỐ (const)** | **PascalCase** | `public const int MaxRetries = 3;` |
| **FIELD (private)** | **camelCase** và có tiền tố `_` | `private string _connectionString;` |
| **PROPERTY (public)** | **PascalCase** | `public string CustomerName { get; set; }` |
| **FORM UI (WinForms/WPF)** | Tiền tố + **PascalCase** | `btnSubmit`, `txtUserName`, `grdCustomerList` |

# 3. **Namespace** là gì?

- Mặc định **C#** đặt tên **namespace** là **project**, có thể chỉnh sửa thành cái khác.
- Là cách đặt tên, chia nhóm cho các **class** để tránh trùng tên và dễ quản lý.
- Giống như các ngăn tủ chứa đồ, mỗi ngăn chứa một loại đồ riêng.
- **Namespace (C#)** = **Package (Java)**.

### Từ khóa `using`
Để sử dụng một `class` từ một `namespace` khác, ta dùng từ khóa `using` ở đầu file.

**Ví dụ:**
```csharp
// File: MyAwesomeApp/DataAccess/CustomerRepository.cs
namespace MyAwesomeApp.DataAccess
{
    public class CustomerRepository 
    {
        // ...
    }
}

// File: MyAwesomeApp/Services/CustomerService.cs
using MyAwesomeApp.DataAccess; // <-- Dùng namespace DataAccess

namespace MyAwesomeApp.Services
{
    public class CustomerService
    {
        private CustomerRepository _repo = new CustomerRepository(); // <-- Có thể dùng class CustomerRepository
    }
}
```

# 4. **Cú pháp Comment** và **Format**

| **Phím tắt** | **Chức năng** |
|---|---|
| `Ctrl + K + C` | **Comment** lại một khối code |
| `Ctrl + K + U` | **Uncomment** một khối code |
| `Ctrl + K + D` | **Format** lại code trong file hiện tại cho đẹp |
| `///` | Tạo **XML Documentation Comment** cho hàm hoặc class. Rất hữu ích để tự động sinh tài liệu. |

**Ví dụ XML Comment:**
```csharp
/// <summary>
/// Calculates the Body Mass Index (BMI).
/// </summary>
/// <param name="weight">Weight in kilograms.</param>
/// <param name="height">Height in meters.</param>
/// <returns>The calculated BMI value.</returns>
public double CalculateBmi(double weight, double height)
{
    // ...
}
```

# 5. **Hàm đặc biệt** & **Body Expression**

Nếu một hàm (hoặc property) chỉ có **duy nhất 1 câu lệnh `return`**, ta có thể viết rút gọn bằng `=>`. Kỹ thuật này gọi là **Expression-bodied member**.

**Ví dụ:**

**Cách viết đầy đủ:**
```csharp
public string GetFullName(string firstName, string lastName)
{
    return $"{firstName} {lastName}";
}
```

**Dùng Expression Body:**
```csharp
public string GetFullName(string firstName, string lastName) => $"{firstName} {lastName}";
```
**Lưu ý:** Đừng nhầm lẫn với **biểu thức LAMBDA**, cũng dùng dấu `=>` nhưng ngữ cảnh và ý nghĩa hoàn toàn khác.

# 6. Có mấy cách gọi một **hàm** (Method)?

Có 2 loại phương thức chính, dẫn đến 2 cách gọi khác nhau:

### a. Gọi **Instance Method** (Phương thức của đối tượng)
- Đây là phương thức thuộc về một **đối tượng cụ thể** (instance) của một `class`.
- Bạn **phải tạo đối tượng** (`new ClassName()`) trước rồi mới gọi được phương thức.

**Ví dụ:**
```csharp
public class Calculator
{
    // Đây là một instance method
    public int Add(int a, int b)
    {
        return a + b;
    }
}

// Cách gọi
Calculator myCalc = new Calculator(); // <-- Phải tạo đối tượng
int sum = myCalc.Add(5, 10); // <-- Gọi phương thức từ đối tượng
```

### b. Gọi **Static Method** (Phương thức tĩnh)
- Đây là phương thức thuộc về chính `class` đó, không thuộc về đối tượng cụ thể nào.
- Bạn gọi trực tiếp từ tên `class` mà **không cần tạo đối tượng**.
- Thường dùng cho các hàm tiện ích (utility functions).

**Ví dụ:**
```csharp
public class MathHelper
{
    // Đây là một static method
    public static double PI = 3.14;

    public static double CalculateCircleArea(double radius)
    {
        return PI * radius * radius;
    }
}

// Cách gọi
double area = MathHelper.CalculateCircleArea(10); // <-- Gọi trực tiếp từ tên class
```
